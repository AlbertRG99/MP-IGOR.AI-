#!/bin/bash

#Creo una estructura de directorios (partiendo de "/") como la siguiente:

mkdir -p mp/ {bin,doc,include,lib,obj,src}

#Creo un archivo del tipo "Hola Mundo con el siguiente codigo y lo guardo en el directorio SRC"

echo "#include <iostream>
using namespace std;

int main(){
 cout << "\n Hola Mundo \n";
}" > ~/mp/src/holaMundo.cpp

#Para compilar usaré la siguiente estructura "g++ -o nombre-ejecutable nombre-fuente"
#Ahora voy a hacer un binario de "holaMundo.cpp" y lo voy a almacenar en el directorio "bin"(binary) con el nombre "holaMundo";
#Posteriormente lo voy a compilar y depués ejecutar con "./".

g++ -o bin/holaMundo src/holaMundo.cpp
./bin/holaMundo

#A recordar:
#
#Pre-Procesador: Integrado en el gc++, recibe el código fuente de las cabeceras (.h) y los programas (.cpp) y devuelve el código fuente procesado.
#Compilador:Recibre el código fuente pre-procesado, analiza sintáctica, semaántica y léxicamente y  devuelve el código objeto (.o).
#Linker:Recibe el código objeto y las bibliotecas y vuelve a devolver el ejecutable en código máquina.

#Ejemplo:
#Construyo una version modular de "demo1.cpp":

echo '
#include <iostream>
#include "oper2.h

using namespace std;
int main(int arg, char *argv[]){
  int a, b;
  cout <<"Introduce el primer valor: ";
  cin >> a;
  cout <<"Introduce el segundo valor";
  cin >> b;
  cout <<"suma = " << suma(a,b) << endl;
  cout <<"resta = " << resta(a,b) <<endl;
  return 0;
}' > demo1.cpp

#Copio demo1.cpp a demo2.cpp (en ~/src):

cp demo1.cpp ~/mp/src/demo2.cpp

#Creao un fichero oper2.h (en include) que contendrá la definición de
#las funciones (la interface del módulo):

echo'
int suma (int a, int b);
int resta (int a, int b);
int multiplica (int a, int b);
int divide (int a, int b);
' > ~/mp/include/oper2.h

#Crear un nuevo fichero oper2.cpp (en src) que contenga la implementación
# de las funciones suma, resta, multiplicación y división (la implementación del módulo):

echo'
#include "oper2.sh"

int suma (int a, int b){
  return a + b;
}
int resta (int a, int b){
  return a - b;
}

int multiplica (int a, int b){
  return a * b;
}

int divide (int a, int b){
  return a / b;
}' > ~/mp/src/oper2.cpp

#En demo2.cpp agrego una línea #include “oper2.h”:

sed -i '#include "oper2.h"' ~/mp/src/oper2.cpp


---------------#CONSTRUCCIÓN DE LA BIBLIOTECA:-------------------

#La extensión de las bibliotecas es " .a" y suelen comenzar con la palabra "lib"
#En este caso mi biblioteca se llamará "liboper.a".
#La guardaremos en el directorio "lib"
#contendrá un solo fichero objeto llamado "oper.o"

#CONSTRUYO LA BIBLIOTECA:
#Usando el comando "ar" y pasando los parametros del programa con "rvs"

ar rvs ~/mp/lib/liboper2.a ~/mp/obj/oper2.o

#Ahora ENLAZO LA BIBLIOTECA:
#Para construir el ejecutable uso la opcion "-l" (libreria), seguida de el nombre de la biblioteca (sin poner el prefijo lib ni el sufijo .a).
#Para especificar donde hay que usar la biblioteca uso el comando "-L" (En el ejemoplo usaremos el directorio "lib"):

#FUNCIONAMIENTO DE LOS COMANDOS/OPCIONES "-o" y "-c"

# "-o":

#Coloca la salida en el archivo de archivo. Esto se aplica a cualquier tipo de salida que
#           se está produciendo, ya sea un archivo ejecutable, un objeto
#           archivo, un archivo ensamblador o código C preprocesado.
#
#           Si no se especifica -o, el valor predeterminado es poner un archivo ejecutable en
#           a.out, el archivo objeto para source.suffix en source.o, su ensamblador
#           archivo en source.s, un archivo de encabezado precompilado en source.suffix.gch,
#           y todas las fuentes de C preprocesadas en salida estándar.

# "-c":

#Place output in file file.  This applies to whatever sort of output
#          is being produced, whether it be an executable file, an object
#          file, an assembler file or preprocessed C code.
#
#          If -o is not specified, the default is to put an executable file in
#          a.out, the object file for source.suffix in source.o, its assembler
#          file in source.s, a precompiled header file in source.suffix.gch,
#          and all preprocessed C source on standard output.

g++ -o ~/mp/bin/demo2 ~/mp/obj/demo2.o -L.~/mp/lib -loper2

#En vez de hacerlo todo de forma manual podemos crear un archivo MAKEFILE que autocompila todos los archivos, formando el programa final:

#____MAKEFILES____

#Vamos a crear un makefile que compile el programa con el siguiente codigo:

echo '
all : ~/mp/bin/demo2
~/mp/bin/demo2 : ~/mp/obj/demo2.o ~/mp/obj/oper2.o
  g++ -0 ~/mp/bin/demo2 ~/mp/obj/demo2.o ~/mp/obj/oper2.0
~/mp/obj/demo2.o : ~/mp/src/demo2.cpp ~/mp/include/oper2.h
  g++ -c -I.~/mp/include -o ~/mp/obj/demo2.o ~/mp/src/demo2.cpp
~/mp/obj/oper2.o : ~/mp/src/oper2.cpp ~/mp/include/oper2.h
  g++ -c -I.~/mp/include -o ~/mp/obj/oper2.o ~/mp/src/oper2.cpp
'
